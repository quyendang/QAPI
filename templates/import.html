<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Import Data</title>
    <script src="https://unpkg.com/oboe/dist/oboe-browser.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .form-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
        }
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            width: 0%;
        }
        .log {
            margin-top: 20px;
            color: blue;
        }
        .error {
            color: red;
        }
        input[type="file"], input[type="text"], button {
            padding: 10px;
            font-size: 16px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <h1>Import Data to Supabase</h1>
    <div class="form-container">
        <label for="user_id">User ID:</label>
        <input type="text" id="user_id" required>
        <br>
        <label for="file">Select JSON File (large files OK):</label>
        <input type="file" id="file" accept=".json" required>
        <br>
        <button onclick="startImport()">Import</button>
        <div id="progress" class="progress-bar"><div id="progress-fill" class="progress-fill"></div></div>
        <p id="status" class="log"></p>
        <p id="error" class="error"></p>
    </div>

    <script>
        async function startImport() {
            const userId = document.getElementById('user_id').value;
            const fileInput = document.getElementById('file');
            if (!userId || !fileInput.files[0]) {
                document.getElementById('error').innerText = 'Missing User ID or file.';
                return;
            }

            document.getElementById('status').innerText = 'Starting import...';
            const file = fileInput.files[0];
            const fileSize = file.size;
            let totalWords = 0;
            let sentWords = 0;
            let groups = [];
            let lessons = [];
            let wordsBatch = [];
            const BATCH_SIZE = 500; // Gá»­i words theo batch 500

            // Initialize Oboe.js
            const oboeInstance = oboe();

            // Define node patterns for JSON structure
            oboeInstance.node('users.F4pm4km5TiY3NPEegMOkXaPYcKt2.groups.*', function(groupData, path) {
                const groupId = path[path.length - 1];
                groups.push({
                    original_id: groupId,
                    name: groupData.groupName || ''
                });
            }).node('users.F4pm4km5TiY3NPEegMOkXaPYcKt2.groups.*.lessons.*', function(lessonData, path) {
                const lessonId = path[path.length - 1];
                const groupId = path[path.length - 3];
                lessons.push({
                    original_id: lessonId,
                    original_group_id: groupId,
                    name: lessonData.lessonName || ''
                });
            }).node('users.F4pm4km5TiY3NPEegMOkXaPYcKt2.groups.*.lessons.*.words.*', async function(wordData, path) {
                const wordId = path[path.length - 1];
                const lessonId = path[path.length - 3];
                wordsBatch.push({
                    original_lesson_id: lessonId,
                    word: wordData.word || '',
                    type: wordData.wordType || '',
                    pronunciation: wordData.pronunciation || '',
                    meaning: wordData.meaning || '',
                    translate: wordData.eg || '',
                    example: wordData.eg2 || '',
                    word_voice: wordData.usVoice || '',
                    df_voice: wordData.dfVoice || '',
                    eg_voice: wordData.egVoice || '',
                    time: wordData.time || ''
                });
                totalWords++;

                if (wordsBatch.length >= BATCH_SIZE) {
                    await sendWordsBatch(userId, [...wordsBatch]);
                    sentWords += wordsBatch.length;
                    wordsBatch = [];
                    updateProgress((sentWords / totalWords) * 100);
                }
            }).done(async function() {
                document.getElementById('status').innerText = 'Parsing done. Sending data...';

                // Send groups
                if (groups.length > 0) {
                    await sendBatch('/import/groups', userId, { groups });
                }

                // Send lessons
                if (lessons.length > 0) {
                    await sendBatch('/import/lessons', userId, { lessons });
                }

                // Send remaining words
                if (wordsBatch.length > 0) {
                    await sendWordsBatch(userId, wordsBatch);
                }

                document.getElementById('status').innerText = 'Import completed!';
                updateProgress(100);
            }).fail(function(err) {
                document.getElementById('error').innerText = 'Error parsing JSON: ' + err.message;
            });

            // Read file in chunks using FileReader
            const reader = new FileReader();
            let offset = 0;
            const chunkSize = 1024 * 1024; // 1MB chunks
            const slice = file.slice.bind(file);

            function readNextChunk() {
                const blob = slice(offset, offset + chunkSize);
                reader.onload = function(event) {
                    if (event.target.result) {
                        oboeInstance.emit('data', event.target.result);
                        offset += chunkSize;
                        updateProgress((offset / fileSize) * 50); // Progress for reading (50% of total progress)
                        if (offset < fileSize) {
                            readNextChunk();
                        } else {
                            oboeInstance.emit('end');
                        }
                    }
                };
                reader.onerror = function() {
                    document.getElementById('error').innerText = 'Error reading file: ' + reader.error.message;
                };
                reader.readAsText(blob);
            }

            readNextChunk();

            async function sendBatch(endpoint, userId, data) {
                data.user_id = userId;
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                const result = await response.json();
                if (result.error) {
                    document.getElementById('error').innerText += '\nError: ' + result.error;
                } else {
                    document.getElementById('status').innerText += '\n' + result.message;
                }
            }

            async function sendWordsBatch(userId, batch) {
                await sendBatch('/import/words', userId, { words: batch });
            }

            function updateProgress(percent) {
                document.getElementById('progress-fill').style.width = Math.min(percent, 100) + '%';
            }
        }
    </script>
</body>
</html>
